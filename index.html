<!DOCTYPE HTML>
<html lang="pt-BR">
    <head>
        <meta charset="UTF-8">
        <!--[if lt IE 9]><script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="assets/css/style.css">
        <title>Respect/Rest - Português/Brasil</title>
        <meta name="title" content="Respect/Rest - Português/Brasil - Documentação PT/BR" />
        <meta name="description" content="Documentação do Respect/Rest em português" />
        <meta name="keywords" content="respect/rest, respect/rest pt, tradução pt respect/rest, documentação respect/rest" />
        <meta name="author" content="Tradução por: Nanderson Castro" />   
        <meta name="url" content="http://cssexperts.net/traducao-respect-rest/" />  
        <meta name="robots" content="INDEX,FOLLOW" />
        <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js?skin=desert"></script>
    </head>
    <body>
        <header>               
            <div class="social">
                <div class="facebook">
                    <div id="fb-root"></div>
                    <script>(function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(d.getElementById(id))return;js=d.createElement(s);js.id=id;js.src="//connect.facebook.net/pt_BR/all.js#xfbml=1&appId=397727050278644";fjs.parentNode.insertBefore(js,fjs)})(document,"script","facebook-jssdk");</script>
                    <div class="fb-like" data-send="false" data-layout="button_count" data-width="450" data-show-faces="false"></div>
                </div>
                <div class="twitter">
                    <a href="https://twitter.com/share" class="twitter-share-button" data-via="NandoKstroNet" data-lang="pt" data-hashtags="respectrest">Tweetar</a>
                    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
                </div>
                <div class="github">
                    <iframe src="http://ghbtns.com/github-btn.html?user=NandoKstroNet&repo=docptbrrespectrest&type=watch&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="80" height="20"></iframe>
                    <iframe src="http://ghbtns.com/github-btn.html?user=NandoKstroNet&repo=docptbrrespectrest&type=fork&count=true" allowtransparency="true" frameborder="0" scrolling="0" width="75" height="20"></iframe>
                    <a href="https://github.com/NandoKstroNet/docptbrrespectrest"><img style="z-index: 999; position: fixed; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>
                </div>
            </div>
            <div class="logo">
                <a href="http://respect.li">
                    <img src="assets/img/respect.png" alt="Respect/Rest" width="140px"/>
                </a>
                <hgroup>
                   <h1>Respect Project</h1>
                   <h2>Respect/Rest</h2>
                </hgroup>
            </div>            
    	</header>	
        <div id="content">
            <div class="progress">

                <div class="load">  
                    Em progresso...                   
                </div>
            </div>
            <p>
                Controlador elegante para aplicações Restful e criação de APIs.
            </p>
            <ul>
                <li>Muito leve e elegante</li>
                <li>Não faz mudanças em seu PHP, pequena curva de aprendizado.</li>
                <li>Completamente RestFul, caminho certo para construir aplicações.</li>
            </ul>
            <h2>Instalação</h2>
            <p>Packages podem ser encontrados no
                <a href="http://respect.li/pear" title="Respect/Rest PEAR">PEAR</a> e <a href="http://packagist.org/packages/Respect/Rest" title="Respect/Rest Composer">Composer</a>.
    			Autoloading compativél com <a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md">PSR-0</a>.
            </p>
            <h2>Configuração</h2>
            <p>Bootstrap é bem simples, basta criar uma instância de Respect\Rest\Router</p>
<pre class="prettyprint">
use <span class="namespace">Respect\Rest\Router</span>;
$r3 = new Router;
</pre>
            <p>Pressupomos que você tenha um .htaccess que redireciona para este arquivo PHP e que esteja executando-o a partir da raiz do dominio (http://example.com/ sem qualquer subpasta).</p>
    		<p>Se você deseja utiliza-lo a partir de uma subpasta, basta passar a caminho para o router:</p>
<pre class="prettyprint">
$r3 = new Router('/myapp');
</pre>
    		<p>Com isto o roteador irá trabalhar a partir de: http://example.com/myapp/</p>
    		<p>Você também pode utilizar o Router sem utilização de um aquivo .htaccess, desta maneira você usará variável CGI <strong>PATH_INFO</strong>, você pode declara-lo da seguinte maneira:</p>
<pre class="prettyprint">
$r3 = new Router('/index.php/');
</pre>
    		<p>Isto presupões que as URLs no projeto iniciarão com esses namespaces.</p>
    		<h2>Dispatching | Executando</h2>
    		<p>O router é auto-executado, você não precisa realizar nenhuma ação para que o mesmo execute de fato, a não ser definir as rotas. Mas caso queira omitir tal comportamento proceda da seguinte maneira:</p>
<pre class="prettyprint">
$r3->isAutoDispatched = false;
</pre>
            <p>Note que para ver as excessões é preciso seguir o próximo passo.</p>
<pre class="prettyprint">
print $r3->run();
</pre>
    		<p>Você pode imprimir a saída ou armazena-la em uma variável, se assim desejar. Isso permite um melhor teste e a integração do Router com sua app existente.</p>
            <h2>Roteamento Simples</h2>
            <p>Um "Olá Mundo" ficaria assim:</p>
<pre class="prettyprint">
$r3->get('/', function() {
	return 'Hello World';
});
</pre>
            <p>Ao acessar http://localhost (Considere sua configuração local para isto) a saída em seu browser será "Hello World". Você pode declarar como rotas o que você desejar:</p>
<pre class="prettyprint">
$r3->get('/hello', function() {
	return 'Hello from Path';
});
</pre>
            <p>Neste caso, ao acessar http://localhost/hello a saída em seu browser será "Hello from Path".</p>
            <h2>Usando parametros</h2>
            <p>Você pode declarar rotas que recebam parâmetros da URL.Para isso cada parâmetro é um /* no caminho da rota. Considerando o exemplo anterior:</p>
<pre class="prettyprint">
$r3->get('/users/*', function($screenName) {
	echo "User {$screenName}";
});
</pre>
            <p>Acessando http://localhost/users/alganet ou qualquer outro nome de usuário, além do Alganet, o resultado será "User alganet"(ou o nome escolhido por você.).Multiplos parâmetros podem ser definidos:</p>
<pre class="prettyprint">
$r3->get('/users/*/lists/*', function($user, $list) {
	return "List {$list} from user {$user}.";
});
</pre>
            <p>Os últimos parâmetros na rota são opcionais por default, basta declarar apenas um <strong>->get('/posts/*')</strong> que irá corresponder a <strong>http://localhost/posts/ </strong> sem nenhum parâmetro. Você pode declarar um segundo <strong>->get('/posts')</strong>, agora o Router irá corresponder corretamente, ou tratar o parâmetro ausente, tornando-os anulavéis na função passada.</p>
<pre class="prettyprint">
$r3->get('/posts/*/*/*', function($year,$month=null,$day=null) {
	/** list posts, month and day are optional */
});
</pre>
            <ol>
                <li>O código acima irá corresponder a <strong>/posts/2010/10/10</strong>, <strong>/posts/2011/01 </strong> e <strong>/posts/2010</strong>.</li>
                <li>Os parametros opcionais são aceitos apenas ao fim do path. A seguinte forma não aceita parametro opcional: <strong>/posts/*/*/*/comments/* </strong>.</li>
            </ol>
    	    <h2>Parâmetro Catch-All | Pegando diversos parâmetros</h2>
            <p>Existem casos em que você precisa pegar um número indefinido de parâmetros. Você pode usar o Route com o parametro catch-all, veja:</p>
<pre class="prettyprint">
$r3->get('/users/*/documents/**', function($user, $documentPath) {
	return readfile(PATH_STORAGE. implode('/', $documentPath));
});
</pre>
            <Ol>
                <li>O exemplo citado acima corresponde a <strong>/users/alganet/documents/foo/bar/baz/anything</strong>. Como retorno o parâmetro $user receberá alganet e $documentPath receberá um array com o seguinte conteúdo [foo,bar,baz,anything].</li>
                <li>Os parâmetros catch-all são definidos por dois astericos: <strong>/**</strong>. </li>
                <li>Parametros catch-all devem aparecer apenas no fim do path. Os asteriscos duplos em outras posições serão sempre convertidos para asteriscos simples.</li>
                <li>Catch-all parameters will match after any other route that matches the same pattern.</li>
            </ol>
            <h2>Rotas correspodentes</h2>
            <p>As coisas podem se tornar muito complexas rapidamente. Temos rotas simples, rota com parâmetros, parâmetros opcionais e parâmetros catch-all. Uma regra simples que se deve ter em mente é que o Respect/Rest coincide com as rotas a partir do mais especifico ao mais genérico.</p>
            <ul>
                <li>Rotas com mais <strong>/</strong> são mais específicas e serão correspondidas primeiro.</li>
                <li>Rotas com parâmetros são menos espcificas que rotas sem parâmetros.</li>
                <li>Rotas com muitos parâmetros são ainda mais menos especificas do que rotas com menos parâmetros.</li>
                <li>Rotas com parâmetros catch-all são menos específicas e serão combinadas depois.</li>
            </ul>
            <p>
                Resumindo: A <strong>/</strong> e o <strong>*</strong> colocam sua rota no topo da lista de prioridades para combina-los.
                Respect/Rest classifica rotas automáticamente, mas é altamente recomendado organizar rotas do mais específico para o mais genérico, isto visa melhorar o desempenho e manutenção do seu código.
            </p>
            <h2>Matching any HTTP Method</h2>
            <p>
                Ás vezes você precisa usar uma rota para  proxy request a outro router. Ao usar o método mágico <strong>any</strong> você poderá passar qualquer requisição HTTP para uma determinada função.
            </p>
<pre class="prettyprint">
 $r3->any('/users/*', function($userName) {
 /** do anything */
 });
</pre>
            <ol>
                <li>Qualquer método HTTP irá corresponder a esta rota.</li>
                <li>
                    Você pode descobrir qual é a requisição utilizando o seguinte método padrão do PHP <strong>$_SERVER['REQUEST_METHOD'];</strong>
                 </li>
            </ol>
            <h2>Class Controllers</h2>
            <p>O método <strong>any</strong> é extremamente útil para vincular classes para os controladores, uma das caracteristicas mais importantes do Respect/Rest.</p>
<pre class="prettyprint">
<span class="namespece">use Respect\Rest\Routable;</span> use Respect\Rest\Routable;

class MyArticle implements Routable {
    public function get($id) { }
    public function delete($id) { }
    public function put($id) { }
}

$r3->any('/article/*', 'MyArticle');
</pre>
            <ol>
                <li>Esta rota vai ligar os métodos de classe para os métodos HTTP correspondentes.</li>
                <li>Os parâmetros serão enviados para os métodos das classes, tais como os retornos apresentado nos exemplos anteriores.</li>
                <li>Os controladores são lazy loaders e persistentes. A classe <strong>MyArticle</strong> será instanciada somente quando uma rota corresponder a um de seus métodos, e esta instância será reutilizada em callbacks subsequentes(redirecionamentos, etc.)</li>
                <li>As classes devem implementar a interface <strong>Respect\Rest\Routable</strong> por questões de segurança. ...</li>
            </ol>
            <p>Passar argumentos do construtor para a classe também é válido:</p>
<pre class="prettyprint">
$r3->any('/images/*', 'ImageController', array($myImageHandler, $myDb));
</pre>
            <ol>
                <li>O exemplo acima vai passar $myImageHandler e $myDb para o construtor da classe ImageController.</li>
            </ol>
            <p>
                Você também pode instaciar a classe a si mesma, se assim desejar:
            </p>
<pre class="prettyprint">
$r3->any('/downloads/*', $myDownloadManager);
</pre>
            <ol>
                <li>O exemplo acima irá atribuir <strong>$myDownloadManager</strong> existente como um controlador.</li>
                <li>Esta instância também é reutilizada pelo <strong>Respect\Rest</strong></li>
            </ol>
            <p>E você ainda pode utilizar um factory ou DI para construir a classe do controlador:</p>
<pre class="prettyprint">
$r3->any('/downloads/*', 'MyControllerClass', array('Factory', 'getController'));
</pre>
            <ol>
                <li>O exemplo acima irá utilizar a classe <strong>MyController</strong> retornado por <strong>Factory::getController</strong> .</li>
                <li>Esta instância também é reutilizada pelo <strong>Respect\Rest</strong> .</li>
                <li>O terceiro parâmetro é qualquer variável que pode ser chamada, assim você pode colocar uma closure para construir um exemplo, se assim desejar.</li>
            </ol>
            <h2>Routing Streams | Streams de rota.</h2>
            <p>
                Em muitos casos você necessita de rotas para servir usuários de streams. O roteador não necessita primeiro lidar com arquivos grandes ou precisa esperar o stream terminar antes de servi-lo.
            </p>
<pre class="prettyprint">
$r3->get('/images/*/hi-res', function($imageName) {
    header('Content-type: image/jpg');
    return fopen("/path/to/hi/images/{$imageName}.jpg", 'r');
});
</pre>
            <p>
                O exemplo acima irá redirecionar o arquivo diretamente para o navegador sem mantê-lo na memória.
            </p>
            <p class="red">
                Atenção: Nós criamos uma vunerabilidade de segurança no exemplo: Passando um parâmetro diretamente para um handle <strong>fopen</strong>. Por favor valide todos os parâmetros de entrada do usuário antes de usá-los. Isto foi somente para uma demonstração! 
            </p>
            <h2>Routing Static Values | Roteamento com Valores Estáticos</h2>
            <p>
                Sem surpresas aqui. Você pode fazer uma rota retornar uma cadeia de caracteres simples:
            </p>
<pre class="prettyprint">
$r3->get('/greetings', 'Hello!');
</pre>
            <h2>Forwarding Routes | Rotas de Encaminhamento</h2>
            <p>
                Respect\Rest possui um mecanismo de encaminhamento interno. Primeiramente é preciso entender que cada declaração de rota retorna uma instância:
            </p>
<pre class="prettyprint">
$usersRoute = $r3->any('/users', 'UsersController');
</pre>
            <p>Em seguida, você pode usar(<strong>use</strong>) e retornar(<strong>return</strong>) esta rota em outro script:</p>
<pre class="prettyprint">
$r3->any('/premium', function($user) use ($db, $usersRoute) {
if (!$db->userPremium($user)) {
  return $usersRoute;
}
});
</pre>
            <p>O exemplo acima irá redirecionar o usuário para uma outra rota quando o mesmo não tiver permissões suficientes.</p>
            <h2>When Routine (if) | Rotina (if)</h2>
            <p>
                Respect\Rest usa uma abordagem diferente para validar os parâmetros de rota:
            </p>
<pre class="prettyprint">
$r3->get('/documents/*', function($documentId) {
/** do something */
})->when(function($documentId) {
return is_numeric($documentId) && $documentId > 0;
});
</pre>
            <ol>
                <li>Isso irá corresponder a rota somente se a chamada de retorno for a correspondente.</li>
                <li>O parâmetro <strong>$documentId</strong> deve ter o mesmo nome da ação e da condição.(Mas necessariamente precisar parecer na mesma ordem.)</li>
                <li>Você pode especificar mais de um parâmetro de retorno por cada condição.</li>
                <li>Você pode especificar mais de um callback: <strong>when($cb1)->when($cb2)->when($etc)</strong></li>
                <li>Condições também irão sincronizar com bind parâmetros de classes e métodos de instância.</li>
            </ol>
            <p>
                Isto traz a possibilidade de cada usuário validar parâmetros usando qualquer rotina personalizada e não apenas os tipos de dados como o <strong>int</strong> ou <strong>string</strong>.
            </p>
            <p>
                É altamente recomendado utilizar uma biblioteca poderosa de validação neste momento. Veja o <a href="http://github.com/Respect/Validation" target="_blank" title="Respect Validation">Respect\Validation</a>.
            </p>
<pre class="prettyprint">
$r3->get('/images/*/hi-res', function($imageName) {
    header('Content-type: image/jpg');
    return fopen("/path/to/hi/images/{$imageName}.jpg", 'r');
})->when(function($imageName) {
    /** Using Respect Validation alias to `V` */
    return V::alphanum(".")->length(5,155)
            ->noWhitespace()->validate($imageName);
});
</pre>
            <h2>By Routine (before) | Rotina (before)</h2>
            <p>
                Às vezes você precisa executar algo antes que uma rota execute seu trabalho. Isso é útil para registros, autenticações e atividades similares.            
            </p>
<pre class="prettyprint">
$r3->get('/artists/*/albums/*', function($artistName, $albumName) {
/** do something */
})->by(function($albumName) use ($myLogger) {
$myLogger->logAlbumVisit($albumName);
});
</pre>
              <ol>
                  <li>Isto irá executar o callback definido antes da ação da rota que precisa corresponder a uma rota.</li>
                  <li>Os parâmetros são sincronizado pelo nome e não pela ordem, como com <strong>when</strong>.</li>
                  <li>Você pode especificar mais de um parâmetro de retorno por chamada de proxy.</li>
                  <li>Você pode especificar mais de um proxy: <strong>by($cb1)->by($cb2)->by($etc)</strong>.</li>
                  <li>Um <strong>return false</strong> irá parar a execução de qualquer proxy seguinte, bem como as ações da rota.</li>
                  <li>Proxies também irão sincronizar com parâmetros de bind class e métodos de instância.</li>
              </ol>
              <p>
                  Se sua rotina retorna <strong>false</strong>, então o método/função de rota não será processado. Se você retornar uma instância de outra rota, então o próximo método interno será executado.
              </p>
              <h2>Through Routine (after) | Através da rotina(after)</h2>
              <p>
                  Similar ao <strong>->by</strong>, porém é executado após a rota fazer seu trabalho. No exemplo a seguir, nós estamos mostrando algo semelhante para invalidar um cache depois de enviar e salvar algumas informações novas.
              </p>
<pre class="prettyprint">
$r3->post('/artists/*/albums/*', function($artistName, $albumName) {
/** save some artist info */
})->through(function() use($myCache) {
$myCache->clear($artistName, $albumName);
});
</pre>
              <div class="progress">
                    <div class="load">  
                        Continua...                   
                    </div>
                </div>
            </div><!--Fecha Div Content-->
    </body>
</html>
